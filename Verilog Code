module traffic_light(
  input clk,
  input rst,
  output reg [2:0] light_M1,
  output reg [2:0] light_S,
  output reg [2:0] light_MT,
  output reg [2:0] light_M2,
  output reg [3:0] count,   // Added count as an output
  output reg [2:0] ps       // Added ps as an output
);

  // State parameters
  parameter s1 = 0, s2 = 1, s3 = 2, s4 = 3, s5 = 4, s6 = 5;

  // Adjustable delay parameters (can be modified as needed)
  parameter delay_s1 = 4'd7; // Replace sec7
  parameter delay_s2 = 4'd2; // Replace sec2
  parameter delay_s3 = 4'd5; // Replace sec5
  parameter delay_s4 = 4'd2; // Replace sec2
  parameter delay_s5 = 4'd3; // Replace sec3
  parameter delay_s6 = 4'd2; // Replace sec2

  reg [3:0] delay; // Variable to hold the current delay count for each state

  always @(posedge clk or posedge rst) begin
    if (rst) begin
      ps <= s1;
      count <= 0;
      delay <= delay_s1; // Set the initial delay based on state s1
    end else begin
      if (count < delay) begin
        count <= count + 1;
      end else begin
        count <= 0;
        case (ps)
          s1: begin
            ps <= s2;
            delay <= delay_s2; // Update delay for the next state
          end
          s2: begin
            ps <= s3;
            delay <= delay_s3;
          end
          s3: begin
            ps <= s4;
            delay <= delay_s4;
          end
          s4: begin
            ps <= s5;
            delay <= delay_s5;
          end
          s5: begin
            ps <= s6;
            delay <= delay_s6;
          end
          s6: begin
            ps <= s1;
            delay <= delay_s1;
          end
          default: begin
            ps <= s1;
            delay <= delay_s1;
          end
        endcase
      end
    end
  end

  // State-based light control logic
  always @(ps) begin
    case (ps)
      s1: begin
        light_M1 <= 3'b001;
        light_M2 <= 3'b001;
        light_MT <= 3'b100;
        light_S  <= 3'b100;
      end
      s2: begin
        light_M1 <= 3'b001;
        light_M2 <= 3'b010;
        light_MT <= 3'b100;
        light_S  <= 3'b100;
      end
      s3: begin
        light_M1 <= 3'b001;
        light_M2 <= 3'b100;
        light_MT <= 3'b001;
        light_S  <= 3'b100;
      end
      s4: begin
        light_M1 <= 3'b010;
        light_M2 <= 3'b010;
        light_MT <= 3'b100;
        light_S  <= 3'b100;
      end
      s5: begin
        light_M1 <= 3'b100;
        light_M2 <= 3'b100;
        light_MT <= 3'b100;
        light_S  <= 3'b001;
      end
      s6: begin
        light_M1 <= 3'b100;
        light_M2 <= 3'b100;
        light_MT <= 3'b100;
        light_S  <= 3'b100;
      end
      default: begin
        light_M1 <= 3'b000;
        light_M2 <= 3'b000;
        light_MT <= 3'b000;
        light_S  <= 3'b000;
      end
    endcase
  end

endmodule

module traffic_light_TB;
  reg clk, rst;
  wire [2:0] light_M1;
  wire [2:0] light_S;
  wire [2:0] light_MT;
  wire [2:0] light_M2;
  wire [3:0] count;
  wire [2:0] ps;

  // Instantiate traffic_light
  traffic_light dut (
    .clk(clk), 
    .rst(rst), 
    .light_M1(light_M1), 
    .light_S(light_S), 
    .light_MT(light_MT), 
    .light_M2(light_M2),
    .count(count),    // Connect count to the testbench
    .ps(ps)           // Connect ps to the testbench
  );

  // Clock generation
  initial begin
    clk = 1'b0;
    forever #5 clk = ~clk; // Toggle clock every 5 time units for simulation
  end
  
  // Test stimulus
  initial begin
    rst = 1;         // Start with reset high
    #10 rst = 0;     // Release reset after 10 time units
    #2000 $finish;   // End simulation after a set time (adjust as needed)
  end
endmodule
